# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Create dist directory
        run: mkdir -p dist
      - name: Build Tailwind CSS
        run: npx tailwindcss -i ./src/styles/main.css -o ./dist/output.css --minify
      - name: Copy index.html to dist
        run: cp index.html dist/
      - name: Update CSS path in index.html
        run: |
          sed -i 's|<link href="./src/styles/main.css" rel="stylesheet">|<link href="./output.css" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.0/dist/tailwind.min.css" rel="stylesheet">|g' dist/index.html
      - name: Update JS path in index.html
        run: |
          sed -i 's|<script type="module" src="/src/scripts/main.js"></script>|<script type="module" src="./scripts/main.js"></script>|g' dist/index.html
      - name: Create proper directory structure for JS files
        run: |
          mkdir -p dist/scripts
          mkdir -p dist/scripts/utils
      - name: Copy JS files to dist
        run: |
          cp src/scripts/*.js dist/scripts/
          cp -r src/scripts/utils/* dist/scripts/utils/
      - name: Fix import paths in JS files
        run: |
          find dist/scripts -type f -name "*.js" -exec sed -i 's|from "./utils/|from "./utils/|g' {} \;
          find dist/scripts -type f -name "*.js" -exec sed -i 's|from "../|from "./|g' {} \;
          find dist/scripts -type f -name "*.js" -exec sed -i 's|from "/src/|from "./|g' {} \;
      - name: Add CDN imports for Chart.js and jsPDF
        run: |
          sed -i 's|</head>|<script src="https://cdn.jsdelivr.net/npm/chart.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script><script src="https://unpkg.com/jspdf-autotable@3.5.28/dist/jspdf.plugin.autotable.js"></script></head>|g' dist/index.html
      - name: Create bundle.js with all dependencies
        run: |
          cat > dist/scripts/bundle.js << 'EOL'
          // Global variables
          window.Chart = Chart;
          window.jsPDF = jspdf.jsPDF;
          
          // Initialize application when DOM is loaded
          document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing application...');
            
            // Dark mode toggle
            const darkModeToggle = document.getElementById('darkModeToggle');
            if (darkModeToggle) {
              const isDarkMode = localStorage.getItem('darkMode') === 'true';
              document.documentElement.classList.toggle('dark', isDarkMode);
              
              darkModeToggle.addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
              });
            }
            
            // Weight sliders
            const weightA = document.getElementById('weightA');
            const weightB = document.getElementById('weightB');
            const weightAValue = document.getElementById('weightAValue');
            const weightBValue = document.getElementById('weightBValue');
            
            if (weightA && weightAValue) {
              weightAValue.textContent = `${parseInt(weightA.value * 100)}%`;
              weightA.addEventListener('input', () => {
                weightAValue.textContent = `${parseInt(weightA.value * 100)}%`;
              });
            }
            
            if (weightB && weightBValue) {
              weightBValue.textContent = `${parseInt(weightB.value * 100)}%`;
              weightB.addEventListener('input', () => {
                weightBValue.textContent = `${parseInt(weightB.value * 100)}%`;
              });
            }
            
            // Run simulation button
            const runButton = document.getElementById('runSimulation');
            if (runButton) {
              runButton.addEventListener('click', async () => {
                try {
                  runButton.disabled = true;
                  runButton.innerHTML = '⌛ Procesando...';
                  
                  // Get input values
                  const meanX = parseFloat(document.getElementById('meanX').value);
                  const stdX = parseFloat(document.getElementById('stdX').value);
                  const meanY = parseFloat(document.getElementById('meanY').value);
                  const stdY = parseFloat(document.getElementById('stdY').value);
                  const weightA = parseFloat(document.getElementById('weightA').value);
                  const weightB = parseFloat(document.getElementById('weightB').value);
                  const numSims = parseInt(document.getElementById('numSims').value);
                  
                  // Run simulation
                  const results = runMonteCarloSimulation(meanX, stdX, meanY, stdY, weightA, weightB, numSims);
                  
                  // Update UI
                  updateUI(results);
                  updateDistributionChart(results.portfolioReturns);
                  updateCovarianceMatrix(results);
                  updateInterpretation(results, weightA, weightB);
                  
                  // Show success message
                  showMessage('Simulación completada con éxito', 'success');
                } catch (error) {
                  console.error('Error en la simulación:', error);
                  showMessage('Error en la simulación: ' + error.message, 'error');
                } finally {
                  runButton.disabled = false;
                  runButton.innerHTML = '🚀 Ejecutar Simulación';
                }
              });
            }
            
            // Helper functions
            function showMessage(message, type) {
              const element = document.getElementById(type === 'success' ? 'success-message' : 'error-message');
              if (element) {
                element.textContent = message;
                element.classList.remove('translate-x-full');
                setTimeout(() => {
                  element.classList.add('translate-x-full');
                }, 3000);
              }
            }
            
            // Monte Carlo simulation
            function runMonteCarloSimulation(meanX, stdX, meanY, stdY, weightA, weightB, numSims) {
              const xReturns = [];
              const yReturns = [];
              const portfolioReturns = [];
              
              // Generate simulated returns
              for (let i = 0; i < numSims; i++) {
                const x = generateNormalRandom(meanX, stdX);
                const y = generateNormalRandom(meanY, stdY);
                const portfolio = weightA * x + weightB * y;
                
                xReturns.push(x);
                yReturns.push(y);
                portfolioReturns.push(portfolio);
              }
              
              // Calculate statistics
              const stats = calculateStatistics(xReturns, yReturns, portfolioReturns);
              
              return {
                xReturns,
                yReturns,
                portfolioReturns,
                ...stats,
                weightA,
                weightB
              };
            }
            
            // Generate normal random numbers
            function generateNormalRandom(mean = 0, std = 1) {
              let u = 0, v = 0;
              while (u === 0) u = Math.random();
              while (v === 0) v = Math.random();
              
              const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
              return z * std + mean;
            }
            
            // Calculate statistics
            function calculateStatistics(xReturns, yReturns, portfolioReturns) {
              const n = xReturns.length;
              
              // Means
              const meanX = xReturns.reduce((sum, x) => sum + x, 0) / n;
              const meanY = yReturns.reduce((sum, y) => sum + y, 0) / n;
              const meanPortfolio = portfolioReturns.reduce((sum, r) => sum + r, 0) / n;
              
              // Variances
              const varX = xReturns.reduce((sum, x) => sum + Math.pow(x - meanX, 2), 0) / (n - 1);
              const varY = yReturns.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0) / (n - 1);
              const varPortfolio = portfolioReturns.reduce((sum, r) => sum + Math.pow(r - meanPortfolio, 2), 0) / (n - 1);
              
              // Covariances
              const covXY = xReturns.reduce((sum, x, i) => {
                return sum + (x - meanX) * (yReturns[i] - meanY);
              }, 0) / (n - 1);
              
              // Sharpe ratio (assuming risk-free rate = 0 for simplicity)
              const sharpeRatio = meanPortfolio / Math.sqrt(varPortfolio);
              
              // Value at Risk (VaR) at 95%
              const sortedReturns = [...portfolioReturns].sort((a, b) => a - b);
              const var95 = sortedReturns[Math.floor(0.05 * n)];
              
              return {
                meanX,
                meanY,
                meanPortfolio,
                varX,
                varY,
                varPortfolio,
                covXY,
                stdX: Math.sqrt(varX),
                stdY: Math.sqrt(varY),
                stdPortfolio: Math.sqrt(varPortfolio),
                sharpeRatio,
                var95
              };
            }
            
            // Update UI with results
            function updateUI(results) {
              // Update metrics
              updateElement('portfolioReturn', results.meanPortfolio, formatPercentage);
              updateElement('portfolioRisk', results.stdPortfolio, formatPercentage);
              updateElement('sharpeRatio', results.sharpeRatio, value => value.toFixed(3));
              updateElement('var95', results.var95, formatPercentage);
              
              // Update colors
              updateMetricColor('portfolioReturn', results.meanPortfolio >= 0);
              updateMetricColor('portfolioRisk', false);
              updateMetricColor('sharpeRatio', results.sharpeRatio > 1);
              updateMetricColor('var95', results.var95 >= 0);
            }
            
            // Helper function to update elements
            function updateElement(id, value, formatter = null) {
              const element = document.getElementById(id);
              if (element) {
                element.textContent = formatter ? formatter(value) : value;
              }
            }
            
            // Format percentage
            function formatPercentage(value) {
              return `${(value * 100).toFixed(2)}%`;
            }
            
            // Update metric colors
            function updateMetricColor(elementId, isPositive) {
              const element = document.getElementById(elementId);
              if (element) {
                element.classList.remove('text-finance-bull', 'text-finance-bear');
                
                if (elementId === 'portfolioRisk' || elementId === 'var95') {
                  element.classList.add('text-finance-bear');
                } else {
                  element.classList.add(isPositive ? 'text-finance-bull' : 'text-finance-bear');
                }
              }
            }
            
            // Update distribution chart
            function updateDistributionChart(portfolioReturns) {
              const chartCanvas = document.getElementById('distributionChart');
              if (!chartCanvas) return;
              
              // Clear existing chart
              const existingChart = Chart.getChart(chartCanvas);
              if (existingChart) {
                existingChart.destroy();
              }
              
              // Create bins for histogram
              const bins = 50;
              const min = Math.min(...portfolioReturns);
              const max = Math.max(...portfolioReturns);
              const binSize = (max - min) / bins;
              
              const histogram = new Array(bins).fill(0);
              const labels = [];
              
              // Initialize labels
              for (let i = 0; i < bins; i++) {
                labels.push((min + i * binSize).toFixed(3));
              }
              
              // Count occurrences in each bin
              portfolioReturns.forEach(value => {
                let binIndex = Math.min(Math.floor((value - min) / binSize), bins - 1);
                histogram[binIndex]++;
              });
              
              // Create chart
              new Chart(chartCanvas.getContext('2d'), {
                type: 'bar',
                data: {
                  labels: labels,
                  datasets: [{
                    label: 'Distribución de Retornos',
                    data: histogram,
                    backgroundColor: 'rgba(102, 126, 234, 0.7)',
                    borderColor: 'rgba(102, 126, 234, 1)',
                    borderWidth: 1
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: {
                      display: false
                    },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          return `Frecuencia: ${context.raw}`;
                        },
                        title: function(context) {
                          const minVal = parseFloat(context[0].label);
                          const maxVal = minVal + binSize;
                          return `Retorno: ${minVal.toFixed(3)} a ${maxVal.toFixed(3)}`;
                        }
                      }
                    }
                  },
                  scales: {
                    x: {
                      title: {
                        display: true,
                        text: 'Retorno del Portfolio',
                        color: '#6b7280',
                        font: {
                          weight: 'bold'
                        }
                      },
                      grid: {
                        display: false
                      }
                    },
                    y: {
                      title: {
                        display: true,
                        text: 'Frecuencia',
                        color: '#6b7280',
                        font: {
                          weight: 'bold'
                        }
                      },
                      beginAtZero: true,
                      grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                      }
                    }
                  }
                }
              });
            }
            
            // Update covariance matrix
            function updateCovarianceMatrix(results) {
              // Calculate additional covariances
              const covXPortfolio = results.weightA * results.varX + results.weightB * results.covXY;
              const covYPortfolio = results.weightA * results.covXY + results.weightB * results.varY;
              
              // Update matrix cells
              updateElement('varX', results.varX, value => value.toFixed(6));
              updateElement('covXY', results.covXY, value => value.toFixed(6));
              updateElement('covXPort', covXPortfolio, value => value.toFixed(6));
              updateElement('covYX', results.covXY, value => value.toFixed(6));
              updateElement('varY', results.varY, value => value.toFixed(6));
              updateElement('covYPort', covYPortfolio, value => value.toFixed(6));
              updateElement('covPortX', covXPortfolio, value => value.toFixed(6));
              updateElement('covPortY', covYPortfolio, value => value.toFixed(6));
              updateElement('varPort', results.varPortfolio, value => value.toFixed(6));
              
              // Update list view
              updateElement('varXLabel', results.varX, value => value.toFixed(6));
              updateElement('varYLabel', results.varY, value => value.toFixed(6));
              updateElement('varPortLabel', results.varPortfolio, value => value.toFixed(6));
              updateElement('covXYLabel', results.covXY, value => value.toFixed(6));
            }
            
            // Update interpretation
            function updateInterpretation(results, weightA, weightB) {
              const interpretation = document.getElementById('interpretation');
              if (!interpretation) return;
              
              const sharpeCategory = results.sharpeRatio > 1 ? 'alta' : results.sharpeRatio > 0.5 ? 'moderada' : 'baja';
              const riskLevel = results.stdPortfolio > 0.3 ? 'alto' : results.stdPortfolio > 0.15 ? 'moderado' : 'bajo';
              
              let analysis = `
                <h4 class="text-lg font-semibold text-portfolio-primary mb-4">💡 Análisis del Portfolio</h4>
                <div class="space-y-3">
                  <p><strong>Composición:</strong> ${Math.round(weightA * 100)}% Activo X + ${Math.round(weightB * 100)}% Activo Y</p>
                  <p><strong>Retorno Esperado:</strong> <span class="${results.meanPortfolio >= 0 ? 'text-finance-bull' : 'text-finance-bear'}">${formatPercentage(results.meanPortfolio)}</span> anual</p>
                  <p><strong>Volatilidad (Riesgo):</strong> <span class="text-finance-bear">${formatPercentage(results.stdPortfolio)}</span> (${riskLevel})</p>
                  <p><strong>Ratio de Sharpe:</strong> <span class="${results.sharpeRatio > 1 ? 'text-finance-bull' : 'text-finance-bear'}">${results.sharpeRatio.toFixed(3)}</span> (${sharpeCategory})</p>
                  <p><strong>VaR 95%:</strong> En el peor 5% de los casos, las pérdidas podrían superar el <span class="text-finance-bear">${formatPercentage(Math.abs(results.var95))}</span></p>
                  
                  <div class="mt-4 p-3 bg-slate-100 dark:bg-slate-700 rounded-lg">
                    <h5 class="font-semibold mb-2">🔍 Interpretación de la Matriz de Covarianza:</h5>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                      <li>La varianza del portafolio (${results.varPortfolio.toFixed(6)}) es la suma ponderada de las varianzas y covarianzas de los activos.</li>
                      <li>La covarianza entre X e Y es ${results.covXY >= 0 ? 'positiva' : 'negativa'}, lo que indica que los activos tienden a moverse ${results.covXY >= 0 ? 'en la misma dirección' : 'en direcciones opuestas'}.</li>
                      <li>La diversificación es ${Math.abs(results.covXY) < 0.05 ? 'efectiva' : 'limitada'} debido a la ${Math.abs(results.covXY) < 0.05 ? 'baja' : 'alta'} correlación entre los activos.</li>
                    </ul>
                  </div>
                </div>
              `;
              
              // Recommendation based on Sharpe ratio
              let recommendation = '';
              if (results.sharpeRatio > 1.5) {
                recommendation = 'Excelente relación riesgo-retorno. Considera aumentar la exposición a este portafolio.';
              } else if (results.sharpeRatio > 1) {
                recommendation = 'Buena relación riesgo-retorno. El portafolio es atractivo para inversores con perfil moderado.';
              } else if (results.sharpeRatio > 0.5) {
                recommendation = 'Relación riesgo-retorno aceptable. Considera ajustar los pesos para mejorar el rendimiento.';
              } else {
                recommendation = 'Baja relación riesgo-retorno. Se recomienda revisar la estrategia de inversión.';
              }
              
              analysis += `
                <div class="mt-4 p-3 ${results.sharpeRatio > 1 ? 'bg-green-100 dark:bg-green-900' : 'bg-yellow-100 dark:bg-yellow-900'} rounded-lg">
                  <h5 class="font-semibold mb-1">📌 Recomendación:</h5>
                  <p class="text-sm">${recommendation}</p>
                </div>
              `;
              
              interpretation.innerHTML = analysis;
            }
          });
          EOL
      - name: Update index.html to include bundle.js
        run: |
          sed -i 's|<script type="module" src="./scripts/main.js"></script>|<script src="./scripts/bundle.js"></script>|g' dist/index.html
      - name: Setup Pages
        uses: actions/configure-pages@v4
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          # Upload dist directory
          path: './dist'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v3